
Motion1.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000084  00800200  00000714  000007a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000714  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  00800284  00800284  0000082c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000082c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000158  00000000  00000000  0000085c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001350  00000000  00000000  000009b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000031f  00000000  00000000  00001d04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000649  00000000  00000000  00002023  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002f0  00000000  00000000  0000266c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004fd  00000000  00000000  0000295c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000009fb  00000000  00000000  00002e59  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000160  00000000  00000000  00003854  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__ctors_end>
   4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
   c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  20:	0c 94 6a 03 	jmp	0x6d4	; 0x6d4 <__vector_8>
  24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  2c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  3c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  40:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  44:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__vector_17>
  48:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  4c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  50:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  60:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  64:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  68:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  6c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  70:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  74:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  78:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  7c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  80:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  84:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  88:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  8c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  90:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  94:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  98:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  9c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  a0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  a4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  a8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  ac:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  b0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  b4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  b8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  bc:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  c0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  c4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
  c8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf ef       	ldi	r28, 0xFF	; 255
  d2:	d1 e2       	ldi	r29, 0x21	; 33
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
  d8:	12 e0       	ldi	r17, 0x02	; 2
  da:	a0 e0       	ldi	r26, 0x00	; 0
  dc:	b2 e0       	ldi	r27, 0x02	; 2
  de:	e4 e1       	ldi	r30, 0x14	; 20
  e0:	f7 e0       	ldi	r31, 0x07	; 7
  e2:	00 e0       	ldi	r16, 0x00	; 0
  e4:	0b bf       	out	0x3b, r16	; 59
  e6:	02 c0       	rjmp	.+4      	; 0xec <__do_copy_data+0x14>
  e8:	07 90       	elpm	r0, Z+
  ea:	0d 92       	st	X+, r0
  ec:	a4 38       	cpi	r26, 0x84	; 132
  ee:	b1 07       	cpc	r27, r17
  f0:	d9 f7       	brne	.-10     	; 0xe8 <__do_copy_data+0x10>

000000f2 <__do_clear_bss>:
  f2:	22 e0       	ldi	r18, 0x02	; 2
  f4:	a4 e8       	ldi	r26, 0x84	; 132
  f6:	b2 e0       	ldi	r27, 0x02	; 2
  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>

000000fa <.do_clear_bss_loop>:
  fa:	1d 92       	st	X+, r1

000000fc <.do_clear_bss_start>:
  fc:	a1 39       	cpi	r26, 0x91	; 145
  fe:	b2 07       	cpc	r27, r18
 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
 102:	0e 94 56 02 	call	0x4ac	; 0x4ac <main>
 106:	0c 94 88 03 	jmp	0x710	; 0x710 <_exit>

0000010a <__bad_interrupt>:
 10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <lcd_Wait>:
//	WR=0
//	RD=1

void lcd_Wait()		// Check if the LCD device is busy, if so wait
{	
	PORTC &= 0b00111111; // Clear enable (bit 7), clear Register select (bit 6) 
 10e:	88 b1       	in	r24, 0x08	; 8
 110:	8f 73       	andi	r24, 0x3F	; 63
 112:	88 b9       	out	0x08, r24	; 8
						 // (Set RS low (command register) so can read busy flag)
	PORTG &= 0b11111101; // Clear RD (bit 1) for read operation
 114:	a1 98       	cbi	0x14, 1	; 20
	PORTG |= 0b00000001; // Set WR (bit 0) for read operation
 116:	a0 9a       	sbi	0x14, 0	; 20
	DDRA &= 0b01111111;  // High bit of port A is Busy Flag (BF, bit 7), set to input
 118:	0f 98       	cbi	0x01, 7	; 1
	PORTC |= 0b10000000; // Set enable (bit 7)
 11a:	47 9a       	sbi	0x08, 7	; 8

	while(PINA & 0b10000000); // Wait here until busy flag is cleared
 11c:	07 99       	sbic	0x00, 7	; 0
 11e:	fe cf       	rjmp	.-4      	; 0x11c <lcd_Wait+0xe>

	PORTC &= 0b01111111; // Clear enable (bit 7)
 120:	47 98       	cbi	0x08, 7	; 8
	PORTG &= 0b11111110; // Clear WR (bit 0) for write operation
 122:	a0 98       	cbi	0x14, 0	; 20
	PORTG |= 0b00000010; // Set RD (bit 1) for write operation
 124:	a1 9a       	sbi	0x14, 1	; 20
	DDRA |= 0b10000000;  // Restore bit 7 of port A to output (for Data use)
 126:	0f 9a       	sbi	0x01, 7	; 1
 128:	08 95       	ret

0000012a <lcd_WriteFunctionCommand>:
}

void lcd_WriteFunctionCommand()	// Output the function command in LCDreg to the LCD
{
	lcd_Wait(); 		// Wait if the LCD device is busy
 12a:	0e 94 87 00 	call	0x10e	; 0x10e <lcd_Wait>
	PORTC &= 0b10111111; // Clear Register select (bit 6) 
 12e:	46 98       	cbi	0x08, 6	; 8
	PORTC |= 0b10000000; // Set enable (bit 7)
 130:	47 9a       	sbi	0x08, 7	; 8
	PORTA = LCDreg;	// Send function command to command register, via port A
 132:	80 91 8e 02 	lds	r24, 0x028E
 136:	82 b9       	out	0x02, r24	; 2
	PORTC &= 0b01111111; // Clear enable (bit 7)
 138:	47 98       	cbi	0x08, 7	; 8
 13a:	08 95       	ret

0000013c <lcd_ReadFunctionCommand>:
}

void lcd_ReadFunctionCommand()	// Read the function command from the LCD into LCDreg
{	
	lcd_Wait(); 		// Wait if the LCD device is busy
 13c:	0e 94 87 00 	call	0x10e	; 0x10e <lcd_Wait>
	PORTC &= 0b10111111; // Clear Register select (bit 6)
 140:	46 98       	cbi	0x08, 6	; 8
	PORTC |= 0b10000000; // Set enable (bit 7)
 142:	47 9a       	sbi	0x08, 7	; 8
	LCDreg = PORTA;	// Read the command register via port A
 144:	82 b1       	in	r24, 0x02	; 2
 146:	80 93 8e 02 	sts	0x028E, r24
	PORTC &= 0b01111111; // Clear enable (bit 7)
 14a:	47 98       	cbi	0x08, 7	; 8
 14c:	08 95       	ret

0000014e <lcd_Clear>:
}

void lcd_Clear()	// Clear the LCD display and set the cursor to the 'home' position
{	
	LCDreg = 0x01; 				// The 'clear' command
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); // Output the command to the LCD
 154:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 158:	08 95       	ret

0000015a <lcd_StandardMode>:
}

void lcd_StandardMode()	// Set the LCD to 8-bit-mode, display window freeze and
						// automatic cursor increment (standard mode)
{
	LCDreg = 0b00111000; 			// Command for 8-Bit-transfer
 15a:	88 e3       	ldi	r24, 0x38	; 56
 15c:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 160:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
	LCDreg = 0b00000110; 			// Command for Increment, display freeze
 164:	86 e0       	ldi	r24, 0x06	; 6
 166:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 16a:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
	LCDreg = 0b00010000; 			// Command for Cursor move, not shift
 16e:	80 e1       	ldi	r24, 0x10	; 16
 170:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 174:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 178:	08 95       	ret

0000017a <lcd_SetCursor>:
}

void lcd_SetCursor(unsigned char cursorPosition)	// Set cursor on the LCD to a specific display position
{
	LCDreg = cursorPosition | 0b10000000; 	// Set bit 7 of the byte
 17a:	80 68       	ori	r24, 0x80	; 128
 17c:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 180:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 184:	08 95       	ret

00000186 <lcd_WriteChar>:
}

void lcd_WriteChar(unsigned char cValue)	// Write the character in LCDreg to the display at the current cursor
											// position (the position is incremented after write)	
{
 186:	cf 93       	push	r28
 188:	c8 2f       	mov	r28, r24
	lcd_Wait(); 		// Wait if the LCD device is busy
 18a:	0e 94 87 00 	call	0x10e	; 0x10e <lcd_Wait>
	PORTC |= 0b11000000;// Set enable (bit 7), Set RS (bit 6) (for data)
 18e:	88 b1       	in	r24, 0x08	; 8
 190:	80 6c       	ori	r24, 0xC0	; 192
 192:	88 b9       	out	0x08, r24	; 8
	PORTA = cValue;  	// Write data character to LCD
 194:	c2 b9       	out	0x02, r28	; 2
	PORTC &= 0b01111111;// Clear enable (bit 7)
 196:	47 98       	cbi	0x08, 7	; 8
}
 198:	cf 91       	pop	r28
 19a:	08 95       	ret

0000019c <lcd_WriteString>:

void lcd_WriteString(unsigned char Text[])
{
 19c:	1f 93       	push	r17
 19e:	cf 93       	push	r28
 1a0:	df 93       	push	r29
 1a2:	ec 01       	movw	r28, r24
	unsigned char Index;
	for(Index = 0;Index < strlen(Text); Index++)
 1a4:	10 e0       	ldi	r17, 0x00	; 0
 1a6:	07 c0       	rjmp	.+14     	; 0x1b6 <lcd_WriteString+0x1a>
	{
		lcd_WriteChar(Text[Index]);
 1a8:	fe 01       	movw	r30, r28
 1aa:	e8 0f       	add	r30, r24
 1ac:	f9 1f       	adc	r31, r25
 1ae:	80 81       	ld	r24, Z
 1b0:	0e 94 c3 00 	call	0x186	; 0x186 <lcd_WriteChar>
}

void lcd_WriteString(unsigned char Text[])
{
	unsigned char Index;
	for(Index = 0;Index < strlen(Text); Index++)
 1b4:	1f 5f       	subi	r17, 0xFF	; 255
 1b6:	81 2f       	mov	r24, r17
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	fe 01       	movw	r30, r28
 1bc:	01 90       	ld	r0, Z+
 1be:	00 20       	and	r0, r0
 1c0:	e9 f7       	brne	.-6      	; 0x1bc <lcd_WriteString+0x20>
 1c2:	31 97       	sbiw	r30, 0x01	; 1
 1c4:	ec 1b       	sub	r30, r28
 1c6:	fd 0b       	sbc	r31, r29
 1c8:	8e 17       	cp	r24, r30
 1ca:	9f 07       	cpc	r25, r31
 1cc:	68 f3       	brcs	.-38     	; 0x1a8 <lcd_WriteString+0xc>
	{
		lcd_WriteChar(Text[Index]);
	}
}
 1ce:	df 91       	pop	r29
 1d0:	cf 91       	pop	r28
 1d2:	1f 91       	pop	r17
 1d4:	08 95       	ret

000001d6 <lcd_on>:
 
void lcd_on()	// Set LCD display on, cursor on and blink on
{
	LCDreg = 0b00001111; 			// Combined command byte
 1d6:	8f e0       	ldi	r24, 0x0F	; 15
 1d8:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 1dc:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 1e0:	08 95       	ret

000001e2 <lcd_CursorOff>:
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
}

void lcd_CursorOff()	// Set Cursor Off	
{
	lcd_ReadFunctionCommand();	// Input the command register value into the LCDreg
 1e2:	0e 94 9e 00 	call	0x13c	; 0x13c <lcd_ReadFunctionCommand>
	LCDreg &= 0b11111101;		// Command value to set cursor off
 1e6:	80 91 8e 02 	lds	r24, 0x028E
 1ea:	8d 7f       	andi	r24, 0xFD	; 253
 1ec:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); // Output the command to the LCD
 1f0:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 1f4:	08 95       	ret

000001f6 <lcd_CursorPositionOff>:
	lcd_WriteFunctionCommand();	// Output the command to the LCD
}

void lcd_CursorPositionOff()	// Set Cursor Position Indicator Off
{
	LCDreg = 0b00001100; 			// Command value to set cursor position indicator off
 1f6:	8c e0       	ldi	r24, 0x0C	; 12
 1f8:	80 93 8e 02 	sts	0x028E, r24
	lcd_WriteFunctionCommand(); 	// Output the command to the LCD
 1fc:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_WriteFunctionCommand>
 200:	08 95       	ret

00000202 <lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit>:
	lcd_SetCursor(column + row);	// Set the cursor position
	lcd_WriteChar(data);	// Write the data byte to the display at current cursor position
}

void lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(unsigned char row, unsigned char column, unsigned char data)
{
 202:	cf 93       	push	r28
 204:	c4 2f       	mov	r28, r20
	// The LCD has 2 rows R = {0 - 1} and 16 columns C = {0 - 15}
	// The cursor position is defined in a single byte as follows: 0b0R00CCCC, so
	// need to mask and shift the passed-in values, before calling lcd_SetCursor()
	column &= 0b00001111;	// Only lower 4 bits are valid, Mask off upper 4 bits
	row &= 0b00000001;		// Only lowest bit is valid, Mask off upper 7 bits
 206:	81 70       	andi	r24, 0x01	; 1
void lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(unsigned char row, unsigned char column, unsigned char data)
{
	// The LCD has 2 rows R = {0 - 1} and 16 columns C = {0 - 15}
	// The cursor position is defined in a single byte as follows: 0b0R00CCCC, so
	// need to mask and shift the passed-in values, before calling lcd_SetCursor()
	column &= 0b00001111;	// Only lower 4 bits are valid, Mask off upper 4 bits
 208:	6f 70       	andi	r22, 0x0F	; 15
	row &= 0b00000001;		// Only lowest bit is valid, Mask off upper 7 bits
	row *= 64;				// Shift row value 6 places to the left
	lcd_SetCursor(column + row);	// Set the cursor position
 20a:	90 e4       	ldi	r25, 0x40	; 64
 20c:	89 9f       	mul	r24, r25
 20e:	60 0d       	add	r22, r0
 210:	11 24       	eor	r1, r1
 212:	86 2f       	mov	r24, r22
 214:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
	data += '0';			// Add ASCII '0' to the data value (convert a decimal number into its character representation)
	lcd_WriteChar(data);	// Write the data byte to the display at current cursor position
 218:	80 e3       	ldi	r24, 0x30	; 48
 21a:	8c 0f       	add	r24, r28
 21c:	0e 94 c3 00 	call	0x186	; 0x186 <lcd_WriteChar>
 220:	cf 91       	pop	r28
 222:	08 95       	ret

00000224 <ScanColumns>:

unsigned char ScanColumns(unsigned char RowWeight)
{
	// Read bits 7,6,5,4,3 as high, as only interested in any low values in bits 2,1,0
	unsigned char ColumnPinsValue; 
	ColumnPinsValue = PIND | KeypadMaskColumns; // '0' in any column position means key pressed
 224:	99 b1       	in	r25, 0x09	; 9
 226:	98 6f       	ori	r25, 0xF8	; 248
	ColumnPinsValue = ~ColumnPinsValue;			// '1' in any column position means key pressed
 228:	90 95       	com	r25

	if(KeypadMaskColumn0 == (ColumnPinsValue & KeypadMaskColumn0))
 22a:	92 fd       	sbrc	r25, 2
 22c:	09 c0       	rjmp	.+18     	; 0x240 <ScanColumns+0x1c>
	{
		return RowWeight;		// Indicates current row + column 0
	}
	
	if(KeypadMaskColumn1 == (ColumnPinsValue & KeypadMaskColumn1))
 22e:	91 ff       	sbrs	r25, 1
 230:	02 c0       	rjmp	.+4      	; 0x236 <ScanColumns+0x12>
	{
		return RowWeight + 1;	// Indicates current row + column 1
 232:	8f 5f       	subi	r24, 0xFF	; 255
 234:	08 95       	ret
	}

	if(KeypadMaskColumn2 == (ColumnPinsValue & KeypadMaskColumn2))
 236:	90 ff       	sbrs	r25, 0
 238:	02 c0       	rjmp	.+4      	; 0x23e <ScanColumns+0x1a>
	{
		return RowWeight + 2;	// Indicates current row + column 2
 23a:	8e 5f       	subi	r24, 0xFE	; 254
 23c:	08 95       	ret
	}
	
	return NoKey;	// Indicate no key was pressed
 23e:	8f ef       	ldi	r24, 0xFF	; 255
}
 240:	08 95       	ret

00000242 <ScanKeypad>:
	unsigned char RowWeight;
	unsigned char KeyValue;

// ScanRow0					// Row 0 is connected to port bit 6
	RowWeight = 0x01;		// Remember which row is being scanned
	PORTD = ScanKeypadRow0;	// Set bit 6 low (Row 0), bits 5,4,3 high (rows 1,2,3)
 242:	8f e3       	ldi	r24, 0x3F	; 63
 244:	8b b9       	out	0x0b, r24	; 11
	KeyValue = ScanColumns(RowWeight);	
 246:	81 e0       	ldi	r24, 0x01	; 1
 248:	0e 94 12 01 	call	0x224	; 0x224 <ScanColumns>
	if(NoKey != KeyValue)
 24c:	8f 3f       	cpi	r24, 0xFF	; 255
 24e:	99 f4       	brne	.+38     	; 0x276 <ScanKeypad+0x34>
		return KeyValue;
	}
	
// ScanRow1					// Row 1 is connected to port bit 5
	RowWeight = 0x04;		// Remember which row is being scanned
	PORTD = ScanKeypadRow1;	// Set bit 5 low (Row 1), bits 6,4,3 high (rows 0,2,3)
 250:	8f e5       	ldi	r24, 0x5F	; 95
 252:	8b b9       	out	0x0b, r24	; 11
	KeyValue = ScanColumns(RowWeight);	
 254:	84 e0       	ldi	r24, 0x04	; 4
 256:	0e 94 12 01 	call	0x224	; 0x224 <ScanColumns>
	if(NoKey != KeyValue)
 25a:	8f 3f       	cpi	r24, 0xFF	; 255
 25c:	61 f4       	brne	.+24     	; 0x276 <ScanKeypad+0x34>
		return KeyValue;
	}

// ScanRow2					// Row 2 is connected to port bit 4
	RowWeight = 0x07;		// Remember which row is being scanned
	PORTD = ScanKeypadRow2;	// Set bit 4 low (Row 2), bits 6,5,3 high (rows 0,1,3)
 25e:	8f e6       	ldi	r24, 0x6F	; 111
 260:	8b b9       	out	0x0b, r24	; 11
	KeyValue = ScanColumns(RowWeight);	
 262:	87 e0       	ldi	r24, 0x07	; 7
 264:	0e 94 12 01 	call	0x224	; 0x224 <ScanColumns>
	if(NoKey != KeyValue)
 268:	8f 3f       	cpi	r24, 0xFF	; 255
 26a:	29 f4       	brne	.+10     	; 0x276 <ScanKeypad+0x34>
		return KeyValue;
	}

// ScanRow3					// Row 3 is connected to port bit 3
	RowWeight = 0x0A;		// Remember which row is being scanned
	PORTD = ScanKeypadRow3;	// Set bit 3 low (Row 3), bits 6,5,4 high (rows 0,1,2)
 26c:	87 e7       	ldi	r24, 0x77	; 119
 26e:	8b b9       	out	0x0b, r24	; 11
	KeyValue = ScanColumns(RowWeight);	
 270:	8a e0       	ldi	r24, 0x0A	; 10
 272:	0e 94 12 01 	call	0x224	; 0x224 <ScanColumns>
	return KeyValue;
}
 276:	08 95       	ret

00000278 <EEPROM_write_Byte>:
{		
	// Assembly routine needed here as the access to EEPROM is timing critical and 'write' DOES NOT work in C
	unsigned char cAddress_H = uiAddress / 256;		// The upper byte of address value
	unsigned char cAddress_L = uiAddress % 256;		// The lower byte of address value

asm volatile (
 278:	29 2f       	mov	r18, r25
 27a:	38 2f       	mov	r19, r24
 27c:	f8 94       	cli

0000027e <EEPROM_write1_ASM>:
 27e:	f9 99       	sbic	0x1f, 1	; 31
 280:	fe cf       	rjmp	.-4      	; 0x27e <EEPROM_write1_ASM>
 282:	22 bd       	out	0x22, r18	; 34
 284:	31 bd       	out	0x21, r19	; 33
 286:	60 bd       	out	0x20, r22	; 32
 288:	fa 9a       	sbi	0x1f, 2	; 31
 28a:	f9 9a       	sbi	0x1f, 1	; 31
 28c:	78 94       	sei
 28e:	08 95       	ret

00000290 <EEPROM_read_Byte>:
	// Assembly routine needed here as the access to EEPROM is timing critical and 'read' MAY not work reliably in C
	unsigned char cAddress_H = uiAddress / 256;		// The upper byte of address value
	unsigned char cAddress_L = uiAddress % 256;		// The lower byte of address value
	unsigned char ucData;

asm volatile (
 290:	29 2f       	mov	r18, r25
 292:	38 2f       	mov	r19, r24
 294:	f8 94       	cli

00000296 <EEPROM_write2_ASM>:
 296:	f9 99       	sbic	0x1f, 1	; 31
 298:	fe cf       	rjmp	.-4      	; 0x296 <EEPROM_write2_ASM>
 29a:	22 bd       	out	0x22, r18	; 34
 29c:	31 bd       	out	0x21, r19	; 33
 29e:	f8 9a       	sbi	0x1f, 0	; 31
 2a0:	80 b5       	in	r24, 0x20	; 32
 2a2:	78 94       	sei
	: "a"(cAddress_H), "a"(cAddress_L)	 	// Input parameters in the order mapped onto %1 %2
	:										// Affected general-purpose registers (none in this case), example syntax:	"%r16","%r17","%r18" 
	 );

	return ucData;
 2a4:	08 95       	ret

000002a6 <AlarmSound>:
	}	
}

void AlarmSound() //Plays a siren sound and sends the program into an infinite loop, program termination.
{
	lcd_Clear();
 2a6:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_SetCursor(0x00);
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
	lcd_WriteString("Incorrect!!");
 2b0:	80 e0       	ldi	r24, 0x00	; 0
 2b2:	92 e0       	ldi	r25, 0x02	; 2
 2b4:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2b8:	2f e3       	ldi	r18, 0x3F	; 63
 2ba:	4d e0       	ldi	r20, 0x0D	; 13
 2bc:	83 e0       	ldi	r24, 0x03	; 3
 2be:	21 50       	subi	r18, 0x01	; 1
 2c0:	40 40       	sbci	r20, 0x00	; 0
 2c2:	80 40       	sbci	r24, 0x00	; 0
 2c4:	e1 f7       	brne	.-8      	; 0x2be <AlarmSound+0x18>
 2c6:	00 c0       	rjmp	.+0      	; 0x2c8 <AlarmSound+0x22>
 2c8:	00 00       	nop
 2ca:	25 e0       	ldi	r18, 0x05	; 5
 2cc:	30 e0       	ldi	r19, 0x00	; 0
		}
	}	
}

void AlarmSound() //Plays a siren sound and sends the program into an infinite loop, program termination.
{
 2ce:	e8 ee       	ldi	r30, 0xE8	; 232
 2d0:	73 e0       	ldi	r23, 0x03	; 3
	lcd_WriteString("Incorrect!!");
	_delay_ms(1000);
	
	for (int j = 5; j>0; j--)
	{
		for (int i = 1000; i>0; i--)
 2d2:	64 ef       	ldi	r22, 0xF4	; 244
 2d4:	51 e0       	ldi	r21, 0x01	; 1
 2d6:	1d c0       	rjmp	.+58     	; 0x312 <AlarmSound+0x6c>
		{
			PORTF = ~PORTF;
 2d8:	41 b3       	in	r20, 0x11	; 17
 2da:	40 95       	com	r20
 2dc:	41 bb       	out	0x11, r20	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2de:	a6 ea       	ldi	r26, 0xA6	; 166
 2e0:	aa 95       	dec	r26
 2e2:	f1 f7       	brne	.-4      	; 0x2e0 <AlarmSound+0x3a>
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <AlarmSound+0x40>
 2e6:	01 97       	sbiw	r24, 0x01	; 1
	lcd_WriteString("Incorrect!!");
	_delay_ms(1000);
	
	for (int j = 5; j>0; j--)
	{
		for (int i = 1000; i>0; i--)
 2e8:	00 97       	sbiw	r24, 0x00	; 0
 2ea:	b1 f7       	brne	.-20     	; 0x2d8 <AlarmSound+0x32>
 2ec:	86 2f       	mov	r24, r22
 2ee:	95 2f       	mov	r25, r21
			_delay_us(500);
		}
	
		for (int i = 500; i>0; i--)
		{
			PORTF = ~PORTF;
 2f0:	41 b3       	in	r20, 0x11	; 17
 2f2:	40 95       	com	r20
 2f4:	41 bb       	out	0x11, r20	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2f6:	a9 ef       	ldi	r26, 0xF9	; 249
 2f8:	b0 e0       	ldi	r27, 0x00	; 0
 2fa:	11 97       	sbiw	r26, 0x01	; 1
 2fc:	f1 f7       	brne	.-4      	; 0x2fa <AlarmSound+0x54>
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <AlarmSound+0x5a>
 300:	00 00       	nop
 302:	01 97       	sbiw	r24, 0x01	; 1
		{
			PORTF = ~PORTF;
			_delay_us(500);
		}
	
		for (int i = 500; i>0; i--)
 304:	00 97       	sbiw	r24, 0x00	; 0
 306:	a1 f7       	brne	.-24     	; 0x2f0 <AlarmSound+0x4a>
 308:	21 50       	subi	r18, 0x01	; 1
 30a:	31 09       	sbc	r19, r1
	lcd_Clear();
	lcd_SetCursor(0x00);
	lcd_WriteString("Incorrect!!");
	_delay_ms(1000);
	
	for (int j = 5; j>0; j--)
 30c:	21 15       	cp	r18, r1
 30e:	31 05       	cpc	r19, r1
 310:	19 f0       	breq	.+6      	; 0x318 <AlarmSound+0x72>
		}
	}	
}

void AlarmSound() //Plays a siren sound and sends the program into an infinite loop, program termination.
{
 312:	8e 2f       	mov	r24, r30
 314:	97 2f       	mov	r25, r23
 316:	e0 cf       	rjmp	.-64     	; 0x2d8 <AlarmSound+0x32>
 318:	ff cf       	rjmp	.-2      	; 0x318 <AlarmSound+0x72>

0000031a <WelcomeBeep>:
	WelcomeBeep();
	
}  

void WelcomeBeep() //A beep that informs the user that the program has started
{
 31a:	80 e9       	ldi	r24, 0x90	; 144
 31c:	91 e0       	ldi	r25, 0x01	; 1
	for (int i = 400; i>0; i--)
	{
		PORTF = ~PORTF;
 31e:	21 b3       	in	r18, 0x11	; 17
 320:	20 95       	com	r18
 322:	21 bb       	out	0x11, r18	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 324:	28 ec       	ldi	r18, 0xC8	; 200
 326:	2a 95       	dec	r18
 328:	f1 f7       	brne	.-4      	; 0x326 <WelcomeBeep+0xc>
 32a:	01 97       	sbiw	r24, 0x01	; 1
	
}  

void WelcomeBeep() //A beep that informs the user that the program has started
{
	for (int i = 400; i>0; i--)
 32c:	00 97       	sbiw	r24, 0x00	; 0
 32e:	b9 f7       	brne	.-18     	; 0x31e <WelcomeBeep+0x4>
 330:	8e ee       	ldi	r24, 0xEE	; 238
 332:	92 e0       	ldi	r25, 0x02	; 2
		_delay_us(600);
	}
	
	for (int i = 750; i>0; i--)
	{
		PORTF = ~PORTF;
 334:	21 b3       	in	r18, 0x11	; 17
 336:	20 95       	com	r18
 338:	21 bb       	out	0x11, r18	; 17
 33a:	24 e6       	ldi	r18, 0x64	; 100
 33c:	2a 95       	dec	r18
 33e:	f1 f7       	brne	.-4      	; 0x33c <WelcomeBeep+0x22>
 340:	01 97       	sbiw	r24, 0x01	; 1
	{
		PORTF = ~PORTF;
		_delay_us(600);
	}
	
	for (int i = 750; i>0; i--)
 342:	00 97       	sbiw	r24, 0x00	; 0
 344:	b9 f7       	brne	.-18     	; 0x334 <WelcomeBeep+0x1a>
 346:	8c ed       	ldi	r24, 0xDC	; 220
 348:	95 e0       	ldi	r25, 0x05	; 5
		_delay_us(300);
	}
	
	for (int i = 1500; i>0; i--)
	{
		PORTF = ~PORTF;
 34a:	21 b3       	in	r18, 0x11	; 17
 34c:	20 95       	com	r18
 34e:	21 bb       	out	0x11, r18	; 17
 350:	22 e4       	ldi	r18, 0x42	; 66
 352:	2a 95       	dec	r18
 354:	f1 f7       	brne	.-4      	; 0x352 <WelcomeBeep+0x38>
 356:	00 c0       	rjmp	.+0      	; 0x358 <WelcomeBeep+0x3e>
 358:	01 97       	sbiw	r24, 0x01	; 1
	{
		PORTF = ~PORTF;
		_delay_us(300);
	}
	
	for (int i = 1500; i>0; i--)
 35a:	00 97       	sbiw	r24, 0x00	; 0
 35c:	b1 f7       	brne	.-20     	; 0x34a <WelcomeBeep+0x30>
	{
		PORTF = ~PORTF;
		_delay_us(200);
	}
}
 35e:	08 95       	ret

00000360 <InitialiseGeneral>:
		}
	}
}

void InitialiseGeneral() //Initialising all the ports, interrupts and LCD setup
{
 360:	cf 93       	push	r28
	
	
	//*********************LCD Setup***************************
	//LCD Ports
	DDRA = 0xFF;			// Configure PortA direction Output
 362:	cf ef       	ldi	r28, 0xFF	; 255
 364:	c1 b9       	out	0x01, r28	; 1
	DDRC = 0xFF;			// Configure PortC direction Output
 366:	c7 b9       	out	0x07, r28	; 7
	DDRG = 0xFF;			// Configure PortG direction Output
 368:	c3 bb       	out	0x13, r28	; 19
	
	//LCD Setup
	lcd_Clear();				// Clear the display
 36a:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_StandardMode();			// Set Standard display mode
 36e:	0e 94 ad 00 	call	0x15a	; 0x15a <lcd_StandardMode>
	lcd_on();					// Set the display on
 372:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <lcd_on>
	lcd_CursorOff();			// Set the cursor display off (underscore)
 376:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <lcd_CursorOff>
	lcd_CursorPositionOff();	// Set the cursor position indicator off (flashing square)
 37a:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <lcd_CursorPositionOff>


	//*********************Motion Sensor Setup***************************
	//-------------- RICHARD'S CODE --------------
	//Sensor Ports
	DDRE = 0b01111111; //Sets Port E bit 7 as input
 37e:	8f e7       	ldi	r24, 0x7F	; 127
 380:	8d b9       	out	0x0d, r24	; 13
	PORTE = 0b00000000; // Bits 0-6 form a groundplane, bit 7 pullup resistor NOT set
 382:	1e b8       	out	0x0e, r1	; 14
	
	//Interrupts
	EIFR = 0b11111111;  // Clear all HW interrupt flags
 384:	cc bb       	out	0x1c, r28	; 28
	EICRA = 0b00000000; //External Interrupt Control Register A not used
 386:	10 92 69 00 	sts	0x0069, r1
	EICRB = 0b11000000; //Sets the interrupt to the rising edge
 38a:	80 ec       	ldi	r24, 0xC0	; 192
 38c:	80 93 6a 00 	sts	0x006A, r24
	EIMSK = 0b10000000; // Initially enabled
 390:	80 e8       	ldi	r24, 0x80	; 128
 392:	8d bb       	out	0x1d, r24	; 29
	//*******************************************************************
	
	
	//*********************Keypad Setup***************************
	DDRD = 0b11111000;	// Port D data direction register (row pins output, column pins input)
 394:	88 ef       	ldi	r24, 0xF8	; 248
 396:	8a b9       	out	0x0a, r24	; 10
	PORTD= 0b00000111;	// Set pullups on column pins (so they read '1' when no key is pressed)
 398:	87 e0       	ldi	r24, 0x07	; 7
 39a:	8b b9       	out	0x0b, r24	; 11
	//*******************************************************************
		
	DDRB = 0xFF; // Configure PortD direction Output (LEDs)
 39c:	c4 b9       	out	0x04, r28	; 4
	PORTB = 0XFF; //Set LEDs off at start
 39e:	c5 b9       	out	0x05, r28	; 5
	
	DDRF = 0XFF; //Configure PortF for output (Buzzer)
 3a0:	c0 bb       	out	0x10, r28	; 16
	
	sei();	// Enable interrupts at global level set Global Interrupt Enable (I) bit
 3a2:	78 94       	sei
	
	WelcomeBeep();
 3a4:	0e 94 8d 01 	call	0x31a	; 0x31a <WelcomeBeep>
	
}  
 3a8:	cf 91       	pop	r28
 3aa:	08 95       	ret

000003ac <Timer>:
	}
}

void Timer() //A timer that goes for 1 second -------------- RICHARD'S CODE --------------
{
	TCCR1A = 0b00000000;	// Normal port operation (OC1A, OC1B, OC1C), Clear Timer on 'Compare Match' (CTC) waveform mode)
 3ac:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0b00001101;	// CTC waveform mode, use prescaler 1024
 3b0:	8d e0       	ldi	r24, 0x0D	; 13
 3b2:	80 93 81 00 	sts	0x0081, r24
	TCCR1C = 0b00000000;
 3b6:	10 92 82 00 	sts	0x0082, r1
	
	// For 1 MHz clock (with 1024 prescaler) to achieve a 1 second interval:
	// Need to count 1 million clock cycles (but already divided by 1024)
	// So actually need to count to (1000000 / 1024 =) 976 decimal, = 3D0 Hex
	OCR1AH = 0x03; // Output Compare Registers (16 bit) OCR1BH and OCR1BL
 3ba:	83 e0       	ldi	r24, 0x03	; 3
 3bc:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xD0;
 3c0:	80 ed       	ldi	r24, 0xD0	; 208
 3c2:	80 93 88 00 	sts	0x0088, r24

	TCNT1H = 0b00000000;	// Timer/Counter count/value registers (16 bit) TCNT1H and TCNT1L
 3c6:	10 92 85 00 	sts	0x0085, r1
	TCNT1L = 0b00000000;
 3ca:	10 92 84 00 	sts	0x0084, r1
	TIMSK1 = 0b00000010;	// bit 1 OCIE1A		Use 'Output Compare A Match' Interrupt, i.e. generate an interrupt
 3ce:	82 e0       	ldi	r24, 0x02	; 2
 3d0:	80 93 6f 00 	sts	0x006F, r24
 3d4:	08 95       	ret

000003d6 <RunCode>:
	Menu();
}

int RunCode() //Stage of program when the motion sensor has been turned on
{
    lcd_Clear();
 3d6:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_SetCursor(0x00);
 3da:	80 e0       	ldi	r24, 0x00	; 0
 3dc:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
	lcd_WriteString("Alarm Set");
 3e0:	8c e0       	ldi	r24, 0x0C	; 12
 3e2:	92 e0       	ldi	r25, 0x02	; 2
 3e4:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	alarm = 0;
 3e8:	10 92 84 02 	sts	0x0284, r1
	count = 0; //resets the count to 0
 3ec:	10 92 90 02 	sts	0x0290, r1
	KeyValue=0xFF;
 3f0:	8f ef       	ldi	r24, 0xFF	; 255
 3f2:	80 93 89 02 	sts	0x0289, r24
 		KeyValue = ScanKeypad();

		if (alarm == 2) //for some reason when the PIR is initialised it automatically jumps into the interrupt vector once,
						//after this the PIR works successfully. 
		{			
			time = 10; //amount of seconds to leave for password input
 3f6:	ca e0       	ldi	r28, 0x0A	; 10
	count = 0; //resets the count to 0
	KeyValue=0xFF;
	
    while(1)
    {	
 		KeyValue = ScanKeypad();
 3f8:	0e 94 21 01 	call	0x242	; 0x242 <ScanKeypad>
 3fc:	80 93 89 02 	sts	0x0289, r24

		if (alarm == 2) //for some reason when the PIR is initialised it automatically jumps into the interrupt vector once,
 400:	80 91 84 02 	lds	r24, 0x0284
 404:	82 30       	cpi	r24, 0x02	; 2
 406:	c1 f7       	brne	.-16     	; 0x3f8 <RunCode+0x22>
						//after this the PIR works successfully. 
		{			
			time = 10; //amount of seconds to leave for password input
 408:	c0 93 8f 02 	sts	0x028F, r28
			alarm = 0;
 40c:	10 92 84 02 	sts	0x0284, r1
			Timer();
 410:	0e 94 d6 01 	call	0x3ac	; 0x3ac <Timer>
			MotionDetected();
 414:	0e 94 ca 02 	call	0x594	; 0x594 <MotionDetected>
 418:	ef cf       	rjmp	.-34     	; 0x3f8 <RunCode+0x22>

0000041a <Menu>:
	}
}

void Menu() //Program's main menu, runs on program startup and when password has been successfully entered
{	
	lcd_Clear();
 41a:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_WriteString("1 - Set Password");
 41e:	86 e1       	ldi	r24, 0x16	; 22
 420:	92 e0       	ldi	r25, 0x02	; 2
 422:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	lcd_SetCursor(0x40);
 426:	80 e4       	ldi	r24, 0x40	; 64
 428:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
	lcd_WriteString("2 - Arm Alarm");
 42c:	87 e2       	ldi	r24, 0x27	; 39
 42e:	92 e0       	ldi	r25, 0x02	; 2
 430:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	
	while(1)
	{
		KeyValue = ScanKeypad();
 434:	0e 94 21 01 	call	0x242	; 0x242 <ScanKeypad>
 438:	80 93 89 02 	sts	0x0289, r24
		PORTB = EEPROM_read_Byte(1); //Displays the second digit of the password for troubleshooting 
 43c:	81 e0       	ldi	r24, 0x01	; 1
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	0e 94 48 01 	call	0x290	; 0x290 <EEPROM_read_Byte>
 444:	85 b9       	out	0x05, r24	; 5
		if (KeyValue == 1)
 446:	80 91 89 02 	lds	r24, 0x0289
 44a:	81 30       	cpi	r24, 0x01	; 1
 44c:	41 f4       	brne	.+16     	; 0x45e <Menu+0x44>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 44e:	83 e2       	ldi	r24, 0x23	; 35
 450:	94 ef       	ldi	r25, 0xF4	; 244
 452:	01 97       	sbiw	r24, 0x01	; 1
 454:	f1 f7       	brne	.-4      	; 0x452 <Menu+0x38>
 456:	00 c0       	rjmp	.+0      	; 0x458 <Menu+0x3e>
 458:	00 00       	nop
		{
			DebounceDelay();
			EnterNewPassword();
 45a:	0e 94 45 03 	call	0x68a	; 0x68a <EnterNewPassword>
		}
		
		if (KeyValue == 2)
 45e:	80 91 89 02 	lds	r24, 0x0289
 462:	82 30       	cpi	r24, 0x02	; 2
 464:	39 f7       	brne	.-50     	; 0x434 <Menu+0x1a>
		{
			if (EEPROM_read_Byte(0)!=0xFF) //Checks if a password is stored in the EPROM
 466:	80 e0       	ldi	r24, 0x00	; 0
 468:	90 e0       	ldi	r25, 0x00	; 0
 46a:	0e 94 48 01 	call	0x290	; 0x290 <EEPROM_read_Byte>
 46e:	8f 3f       	cpi	r24, 0xFF	; 255
 470:	41 f0       	breq	.+16     	; 0x482 <Menu+0x68>
 472:	83 e2       	ldi	r24, 0x23	; 35
 474:	94 ef       	ldi	r25, 0xF4	; 244
 476:	01 97       	sbiw	r24, 0x01	; 1
 478:	f1 f7       	brne	.-4      	; 0x476 <Menu+0x5c>
 47a:	00 c0       	rjmp	.+0      	; 0x47c <Menu+0x62>
 47c:	00 00       	nop
			{
				DebounceDelay();
				RunCode();
 47e:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <RunCode>
			}
			
			else //If no password is stored a password will be requested
			{
				lcd_Clear();
 482:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
				lcd_SetCursor(0x00);
 486:	80 e0       	ldi	r24, 0x00	; 0
 488:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
				lcd_WriteString("No Password Set");
 48c:	85 e3       	ldi	r24, 0x35	; 53
 48e:	92 e0       	ldi	r25, 0x02	; 2
 490:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
 494:	9f e3       	ldi	r25, 0x3F	; 63
 496:	2d e0       	ldi	r18, 0x0D	; 13
 498:	83 e0       	ldi	r24, 0x03	; 3
 49a:	91 50       	subi	r25, 0x01	; 1
 49c:	20 40       	sbci	r18, 0x00	; 0
 49e:	80 40       	sbci	r24, 0x00	; 0
 4a0:	e1 f7       	brne	.-8      	; 0x49a <Menu+0x80>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <Menu+0x8a>
 4a4:	00 00       	nop
				_delay_ms(1000);
				EnterNewPassword();
 4a6:	0e 94 45 03 	call	0x68a	; 0x68a <EnterNewPassword>
 4aa:	c4 cf       	rjmp	.-120    	; 0x434 <Menu+0x1a>

000004ac <main>:
unsigned char password[4];


int main(void) //Initial method
{		
	InitialiseGeneral();
 4ac:	0e 94 b0 01 	call	0x360	; 0x360 <InitialiseGeneral>
	Menu();
 4b0:	0e 94 0d 02 	call	0x41a	; 0x41a <Menu>

000004b4 <CheckCode>:
}

void CheckCode() //Ensures that the password is correct
{
	
	while (count > 0)
 4b4:	c0 91 90 02 	lds	r28, 0x0290
 4b8:	cc 23       	and	r28, r28
 4ba:	71 f0       	breq	.+28     	; 0x4d8 <CheckCode+0x24>
	{
		count--;
 4bc:	c1 50       	subi	r28, 0x01	; 1
 4be:	c0 93 90 02 	sts	0x0290, r28
		password[count] = EEPROM_read_Byte(count);		
 4c2:	d0 e0       	ldi	r29, 0x00	; 0
 4c4:	ce 01       	movw	r24, r28
 4c6:	0e 94 48 01 	call	0x290	; 0x290 <EEPROM_read_Byte>
 4ca:	cb 57       	subi	r28, 0x7B	; 123
 4cc:	dd 4f       	sbci	r29, 0xFD	; 253
 4ce:	88 83       	st	Y, r24
}

void CheckCode() //Ensures that the password is correct
{
	
	while (count > 0)
 4d0:	c0 91 90 02 	lds	r28, 0x0290
 4d4:	c1 11       	cpse	r28, r1
 4d6:	f2 cf       	rjmp	.-28     	; 0x4bc <CheckCode+0x8>
	{
		count--;
		password[count] = EEPROM_read_Byte(count);		
	}
	
	if (memcmp(input, password, 4)) // Compares the input array and the password array, returns 1 if the arrays are different
 4d8:	44 e0       	ldi	r20, 0x04	; 4
 4da:	50 e0       	ldi	r21, 0x00	; 0
 4dc:	65 e8       	ldi	r22, 0x85	; 133
 4de:	72 e0       	ldi	r23, 0x02	; 2
 4e0:	8a e8       	ldi	r24, 0x8A	; 138
 4e2:	92 e0       	ldi	r25, 0x02	; 2
 4e4:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <memcmp>
 4e8:	89 2b       	or	r24, r25
 4ea:	11 f0       	breq	.+4      	; 0x4f0 <CheckCode+0x3c>
	{
		AlarmSound();
 4ec:	0e 94 53 01 	call	0x2a6	; 0x2a6 <AlarmSound>
	}
	
	else
	{		
		lcd_Clear();
 4f0:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
		lcd_WriteString("Correct!!");
 4f4:	85 e4       	ldi	r24, 0x45	; 69
 4f6:	92 e0       	ldi	r25, 0x02	; 2
 4f8:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
 4fc:	2f e7       	ldi	r18, 0x7F	; 127
 4fe:	8a e1       	ldi	r24, 0x1A	; 26
 500:	96 e0       	ldi	r25, 0x06	; 6
 502:	21 50       	subi	r18, 0x01	; 1
 504:	80 40       	sbci	r24, 0x00	; 0
 506:	90 40       	sbci	r25, 0x00	; 0
 508:	e1 f7       	brne	.-8      	; 0x502 <CheckCode+0x4e>
 50a:	00 c0       	rjmp	.+0      	; 0x50c <CheckCode+0x58>
 50c:	00 00       	nop
		_delay_ms(2000);
		Menu();
 50e:	0e 94 0d 02 	call	0x41a	; 0x41a <Menu>

00000512 <PasswordEntry>:
	}
}

void PasswordEntry() //Reads in the password entered and displays it on the LCD and also stores it in the input array
{
	if (count < 4 && KeyValue != 12 && KeyValue != 11 && KeyValue != 10)
 512:	60 91 90 02 	lds	r22, 0x0290
 516:	64 30       	cpi	r22, 0x04	; 4
 518:	50 f5       	brcc	.+84     	; 0x56e <PasswordEntry+0x5c>
 51a:	40 91 89 02 	lds	r20, 0x0289
 51e:	4c 30       	cpi	r20, 0x0C	; 12
 520:	51 f1       	breq	.+84     	; 0x576 <PasswordEntry+0x64>
 522:	86 ef       	ldi	r24, 0xF6	; 246
 524:	84 0f       	add	r24, r20
 526:	82 30       	cpi	r24, 0x02	; 2
 528:	a0 f1       	brcs	.+104    	; 0x592 <PasswordEntry+0x80>
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(1, count, KeyValue);
 52a:	81 e0       	ldi	r24, 0x01	; 1
 52c:	0e 94 01 01 	call	0x202	; 0x202 <lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit>
 530:	88 ec       	ldi	r24, 0xC8	; 200
 532:	90 e0       	ldi	r25, 0x00	; 0
		for (int i = 200; i>0; i--)
		{
			PORTF = ~PORTF;
 534:	21 b3       	in	r18, 0x11	; 17
 536:	20 95       	com	r18
 538:	21 bb       	out	0x11, r18	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 53a:	26 ea       	ldi	r18, 0xA6	; 166
 53c:	2a 95       	dec	r18
 53e:	f1 f7       	brne	.-4      	; 0x53c <PasswordEntry+0x2a>
 540:	00 c0       	rjmp	.+0      	; 0x542 <PasswordEntry+0x30>
 542:	01 97       	sbiw	r24, 0x01	; 1
void PasswordEntry() //Reads in the password entered and displays it on the LCD and also stores it in the input array
{
	if (count < 4 && KeyValue != 12 && KeyValue != 11 && KeyValue != 10)
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(1, count, KeyValue);
		for (int i = 200; i>0; i--)
 544:	00 97       	sbiw	r24, 0x00	; 0
 546:	b1 f7       	brne	.-20     	; 0x534 <PasswordEntry+0x22>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 548:	83 e2       	ldi	r24, 0x23	; 35
 54a:	94 ef       	ldi	r25, 0xF4	; 244
 54c:	01 97       	sbiw	r24, 0x01	; 1
 54e:	f1 f7       	brne	.-4      	; 0x54c <PasswordEntry+0x3a>
 550:	00 c0       	rjmp	.+0      	; 0x552 <PasswordEntry+0x40>
 552:	00 00       	nop
		{
			PORTF = ~PORTF;
			_delay_us(500);
		}
		DebounceDelay();
		input[count] = KeyValue;
 554:	80 91 90 02 	lds	r24, 0x0290
 558:	e8 2f       	mov	r30, r24
 55a:	f0 e0       	ldi	r31, 0x00	; 0
 55c:	e6 57       	subi	r30, 0x76	; 118
 55e:	fd 4f       	sbci	r31, 0xFD	; 253
 560:	90 91 89 02 	lds	r25, 0x0289
 564:	90 83       	st	Z, r25
		count++;
 566:	8f 5f       	subi	r24, 0xFF	; 255
 568:	80 93 90 02 	sts	0x0290, r24
 56c:	08 95       	ret
	}
	
	else
	{
		if (KeyValue == 12)
 56e:	80 91 89 02 	lds	r24, 0x0289
 572:	8c 30       	cpi	r24, 0x0C	; 12
 574:	71 f4       	brne	.+28     	; 0x592 <PasswordEntry+0x80>

void PasswordEntry() //Reads in the password entered and displays it on the LCD and also stores it in the input array
{
	if (count < 4 && KeyValue != 12 && KeyValue != 11 && KeyValue != 10)
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(1, count, KeyValue);
 576:	88 ee       	ldi	r24, 0xE8	; 232
 578:	93 e0       	ldi	r25, 0x03	; 3
	{
		if (KeyValue == 12)
		{
			for (int i = 1000; i>0; i--)
			{
				PORTF = ~PORTF;
 57a:	21 b3       	in	r18, 0x11	; 17
 57c:	20 95       	com	r18
 57e:	21 bb       	out	0x11, r18	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 580:	22 e4       	ldi	r18, 0x42	; 66
 582:	2a 95       	dec	r18
 584:	f1 f7       	brne	.-4      	; 0x582 <PasswordEntry+0x70>
 586:	00 c0       	rjmp	.+0      	; 0x588 <PasswordEntry+0x76>
 588:	01 97       	sbiw	r24, 0x01	; 1
	
	else
	{
		if (KeyValue == 12)
		{
			for (int i = 1000; i>0; i--)
 58a:	00 97       	sbiw	r24, 0x00	; 0
 58c:	b1 f7       	brne	.-20     	; 0x57a <PasswordEntry+0x68>
			{
				PORTF = ~PORTF;
				_delay_us(200);
			}
			CheckCode();
 58e:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CheckCode>
 592:	08 95       	ret

00000594 <MotionDetected>:
}

void MotionDetected() //Allows the user 10 seconds to enter the code,
					  //displays the countdown and checks if the countdown is reached
{
	lcd_Clear();
 594:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_SetCursor(0x00);
 598:	80 e0       	ldi	r24, 0x00	; 0
 59a:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
	lcd_WriteString("Motion Detected!");
 59e:	8f e4       	ldi	r24, 0x4F	; 79
 5a0:	92 e0       	ldi	r25, 0x02	; 2
 5a2:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
 	lcd_SetCursor(0x40);
 5a6:	80 e4       	ldi	r24, 0x40	; 64
 5a8:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
 	lcd_WriteString("Enter Key");
 5ac:	80 e6       	ldi	r24, 0x60	; 96
 5ae:	92 e0       	ldi	r25, 0x02	; 2
 5b0:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5b4:	2f e3       	ldi	r18, 0x3F	; 63
 5b6:	8d e0       	ldi	r24, 0x0D	; 13
 5b8:	93 e0       	ldi	r25, 0x03	; 3
 5ba:	21 50       	subi	r18, 0x01	; 1
 5bc:	80 40       	sbci	r24, 0x00	; 0
 5be:	90 40       	sbci	r25, 0x00	; 0
 5c0:	e1 f7       	brne	.-8      	; 0x5ba <MotionDetected+0x26>
 5c2:	00 c0       	rjmp	.+0      	; 0x5c4 <MotionDetected+0x30>
 5c4:	00 00       	nop
 	_delay_ms(1000);
 	lcd_Clear();
 5c6:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
 	lcd_SetCursor(0x00);
 5ca:	80 e0       	ldi	r24, 0x00	; 0
 5cc:	0e 94 bd 00 	call	0x17a	; 0x17a <lcd_SetCursor>
 	lcd_WriteString("Countdown:");
 5d0:	8a e6       	ldi	r24, 0x6A	; 106
 5d2:	92 e0       	ldi	r25, 0x02	; 2
 5d4:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(0,10, time);
		KeyValue = ScanKeypad();
		if(KeyValue != 0xFF)
		{
			PORTB = 0XFF;
 5d8:	cf ef       	ldi	r28, 0xFF	; 255
 	lcd_SetCursor(0x00);
 	lcd_WriteString("Countdown:");
	
	while (1)
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(0,10, time);
 5da:	40 91 8f 02 	lds	r20, 0x028F
 5de:	6a e0       	ldi	r22, 0x0A	; 10
 5e0:	80 e0       	ldi	r24, 0x00	; 0
 5e2:	0e 94 01 01 	call	0x202	; 0x202 <lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit>
		KeyValue = ScanKeypad();
 5e6:	0e 94 21 01 	call	0x242	; 0x242 <ScanKeypad>
 5ea:	80 93 89 02 	sts	0x0289, r24
		if(KeyValue != 0xFF)
 5ee:	8f 3f       	cpi	r24, 0xFF	; 255
 5f0:	19 f0       	breq	.+6      	; 0x5f8 <MotionDetected+0x64>
		{
			PORTB = 0XFF;
 5f2:	c5 b9       	out	0x05, r28	; 5
			PasswordEntry();
 5f4:	0e 94 89 02 	call	0x512	; 0x512 <PasswordEntry>
		}
		
		if (time == 0)
 5f8:	80 91 8f 02 	lds	r24, 0x028F
 5fc:	81 11       	cpse	r24, r1
 5fe:	ed cf       	rjmp	.-38     	; 0x5da <MotionDetected+0x46>
		{
			AlarmSound();
 600:	0e 94 53 01 	call	0x2a6	; 0x2a6 <AlarmSound>

00000604 <NewPasswordEntry>:
	}	
}

void NewPasswordEntry() //Changes the password values in the EPROM
{
	if (count < 4 && KeyValue != 12 && KeyValue != 11 && KeyValue != 10) //the 0 key has been disabled
 604:	60 91 90 02 	lds	r22, 0x0290
 608:	64 30       	cpi	r22, 0x04	; 4
 60a:	50 f5       	brcc	.+84     	; 0x660 <NewPasswordEntry+0x5c>
 60c:	40 91 89 02 	lds	r20, 0x0289
 610:	4c 30       	cpi	r20, 0x0C	; 12
 612:	51 f1       	breq	.+84     	; 0x668 <NewPasswordEntry+0x64>
 614:	86 ef       	ldi	r24, 0xF6	; 246
 616:	84 0f       	add	r24, r20
 618:	82 30       	cpi	r24, 0x02	; 2
 61a:	b0 f1       	brcs	.+108    	; 0x688 <NewPasswordEntry+0x84>
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(1, count, KeyValue);
 61c:	81 e0       	ldi	r24, 0x01	; 1
 61e:	0e 94 01 01 	call	0x202	; 0x202 <lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit>
 622:	88 ec       	ldi	r24, 0xC8	; 200
 624:	90 e0       	ldi	r25, 0x00	; 0
		
		for (int i = 200; i>0; i--)
		{
			PORTF = ~PORTF;
 626:	21 b3       	in	r18, 0x11	; 17
 628:	20 95       	com	r18
 62a:	21 bb       	out	0x11, r18	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 62c:	26 ea       	ldi	r18, 0xA6	; 166
 62e:	2a 95       	dec	r18
 630:	f1 f7       	brne	.-4      	; 0x62e <NewPasswordEntry+0x2a>
 632:	00 c0       	rjmp	.+0      	; 0x634 <NewPasswordEntry+0x30>
 634:	01 97       	sbiw	r24, 0x01	; 1
{
	if (count < 4 && KeyValue != 12 && KeyValue != 11 && KeyValue != 10) //the 0 key has been disabled
	{
		lcd_WriteVariable_withValueAndPositionParameters_SingleDecimalDigit(1, count, KeyValue);
		
		for (int i = 200; i>0; i--)
 636:	00 97       	sbiw	r24, 0x00	; 0
 638:	b1 f7       	brne	.-20     	; 0x626 <NewPasswordEntry+0x22>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 63a:	83 e2       	ldi	r24, 0x23	; 35
 63c:	94 ef       	ldi	r25, 0xF4	; 244
 63e:	01 97       	sbiw	r24, 0x01	; 1
 640:	f1 f7       	brne	.-4      	; 0x63e <NewPasswordEntry+0x3a>
 642:	00 c0       	rjmp	.+0      	; 0x644 <NewPasswordEntry+0x40>
 644:	00 00       	nop
			PORTF = ~PORTF;
			_delay_us(500);
		}
		
		DebounceDelay();
		EEPROM_write_Byte(count, KeyValue);
 646:	80 91 90 02 	lds	r24, 0x0290
 64a:	60 91 89 02 	lds	r22, 0x0289
 64e:	90 e0       	ldi	r25, 0x00	; 0
 650:	0e 94 3c 01 	call	0x278	; 0x278 <EEPROM_write_Byte>
		count++;
 654:	80 91 90 02 	lds	r24, 0x0290
 658:	8f 5f       	subi	r24, 0xFF	; 255
 65a:	80 93 90 02 	sts	0x0290, r24
 65e:	08 95       	ret
	}
	
	else
	{
		if (KeyValue == 12 && count==4)
 660:	80 91 89 02 	lds	r24, 0x0289
 664:	8c 30       	cpi	r24, 0x0C	; 12
 666:	81 f4       	brne	.+32     	; 0x688 <NewPasswordEntry+0x84>
 668:	64 30       	cpi	r22, 0x04	; 4
 66a:	71 f4       	brne	.+28     	; 0x688 <NewPasswordEntry+0x84>
 66c:	88 ee       	ldi	r24, 0xE8	; 232
 66e:	93 e0       	ldi	r25, 0x03	; 3
		{
			for (int i = 1000; i>0; i--)
			{
				PORTF = ~PORTF;
 670:	21 b3       	in	r18, 0x11	; 17
 672:	20 95       	com	r18
 674:	21 bb       	out	0x11, r18	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 676:	22 e4       	ldi	r18, 0x42	; 66
 678:	2a 95       	dec	r18
 67a:	f1 f7       	brne	.-4      	; 0x678 <NewPasswordEntry+0x74>
 67c:	00 c0       	rjmp	.+0      	; 0x67e <NewPasswordEntry+0x7a>
 67e:	01 97       	sbiw	r24, 0x01	; 1
	
	else
	{
		if (KeyValue == 12 && count==4)
		{
			for (int i = 1000; i>0; i--)
 680:	00 97       	sbiw	r24, 0x00	; 0
 682:	b1 f7       	brne	.-20     	; 0x670 <NewPasswordEntry+0x6c>
			{
				PORTF = ~PORTF;
				_delay_us(200);
			}
			
			Menu();
 684:	0e 94 0d 02 	call	0x41a	; 0x41a <Menu>
 688:	08 95       	ret

0000068a <EnterNewPassword>:
}

void EnterNewPassword() //Allows users to change the password, the password will remain the same
						//even after the board has been restarted
{
	count = 0;
 68a:	10 92 90 02 	sts	0x0290, r1
	lcd_Clear();
 68e:	0e 94 a7 00 	call	0x14e	; 0x14e <lcd_Clear>
	lcd_WriteString("New Password:");
 692:	85 e7       	ldi	r24, 0x75	; 117
 694:	92 e0       	ldi	r25, 0x02	; 2
 696:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_WriteString>
	
	KeyValue = 0xFF;
 69a:	8f ef       	ldi	r24, 0xFF	; 255
 69c:	80 93 89 02 	sts	0x0289, r24
	
	while(1)
	{
		KeyValue = ScanKeypad();
 6a0:	0e 94 21 01 	call	0x242	; 0x242 <ScanKeypad>
 6a4:	80 93 89 02 	sts	0x0289, r24
		
		if(KeyValue != 0xFF)
 6a8:	8f 3f       	cpi	r24, 0xFF	; 255
 6aa:	d1 f3       	breq	.-12     	; 0x6a0 <EnterNewPassword+0x16>
		{
			NewPasswordEntry();
 6ac:	0e 94 02 03 	call	0x604	; 0x604 <NewPasswordEntry>
 6b0:	f7 cf       	rjmp	.-18     	; 0x6a0 <EnterNewPassword+0x16>

000006b2 <__vector_17>:
	TIMSK1 = 0b00000010;	// bit 1 OCIE1A		Use 'Output Compare A Match' Interrupt, i.e. generate an interrupt
	// when the timer reaches the set value (in the OCR1A register)
}

ISR(TIMER1_COMPA_vect) //Timer Interrupt, this is used to display a countdown on the LCD
{
 6b2:	1f 92       	push	r1
 6b4:	0f 92       	push	r0
 6b6:	0f b6       	in	r0, 0x3f	; 63
 6b8:	0f 92       	push	r0
 6ba:	11 24       	eor	r1, r1
 6bc:	8f 93       	push	r24
	time--;	
 6be:	80 91 8f 02 	lds	r24, 0x028F
 6c2:	81 50       	subi	r24, 0x01	; 1
 6c4:	80 93 8f 02 	sts	0x028F, r24
}
 6c8:	8f 91       	pop	r24
 6ca:	0f 90       	pop	r0
 6cc:	0f be       	out	0x3f, r0	; 63
 6ce:	0f 90       	pop	r0
 6d0:	1f 90       	pop	r1
 6d2:	18 95       	reti

000006d4 <__vector_8>:

ISR (INT7_vect) // PIR Sensor Interrupt, the alarm value is like a flag, this could be narrowed down to a single digit if needed.
				//Storing the change in a value means that this value can be checked only when needed, at other times the motion
				//sensor interrupt will make no difference to the program. This could also have been achieved by disabling and 
				//enabling the interrupt.
{	
 6d4:	1f 92       	push	r1
 6d6:	0f 92       	push	r0
 6d8:	0f b6       	in	r0, 0x3f	; 63
 6da:	0f 92       	push	r0
 6dc:	11 24       	eor	r1, r1
 6de:	8f 93       	push	r24
	alarm++;
 6e0:	80 91 84 02 	lds	r24, 0x0284
 6e4:	8f 5f       	subi	r24, 0xFF	; 255
 6e6:	80 93 84 02 	sts	0x0284, r24
} 
 6ea:	8f 91       	pop	r24
 6ec:	0f 90       	pop	r0
 6ee:	0f be       	out	0x3f, r0	; 63
 6f0:	0f 90       	pop	r0
 6f2:	1f 90       	pop	r1
 6f4:	18 95       	reti

000006f6 <memcmp>:
 6f6:	fb 01       	movw	r30, r22
 6f8:	dc 01       	movw	r26, r24
 6fa:	04 c0       	rjmp	.+8      	; 0x704 <memcmp+0xe>
 6fc:	8d 91       	ld	r24, X+
 6fe:	01 90       	ld	r0, Z+
 700:	80 19       	sub	r24, r0
 702:	21 f4       	brne	.+8      	; 0x70c <memcmp+0x16>
 704:	41 50       	subi	r20, 0x01	; 1
 706:	50 40       	sbci	r21, 0x00	; 0
 708:	c8 f7       	brcc	.-14     	; 0x6fc <memcmp+0x6>
 70a:	88 1b       	sub	r24, r24
 70c:	99 0b       	sbc	r25, r25
 70e:	08 95       	ret

00000710 <_exit>:
 710:	f8 94       	cli

00000712 <__stop_program>:
 712:	ff cf       	rjmp	.-2      	; 0x712 <__stop_program>
